/**
 * G-SOFT API (Cloudflare Workers + D1)
 * - Auth via cookie "gsoft_session" –¥–æ 23:59:59 (Asia/Tashkent +05:00)
 * - RBAC: admin/pm/fin/sale/rop
 * - Soft delete (is_active=0, deleted_at/by)
 * - Kanban data for tasks/projects/course_leads
 *
 * ENV:
 *   DB                (D1Database) REQUIRED
 *   CORS_ORIGINS       optional, comma-separated exact origins
 *   COOKIE_DOMAIN      optional, e.g. ".ofis.gekto.uz"
 *   TG_BOT_TOKEN       optional, Telegram bot token (for webhook replies)
 *   TG_WEBHOOK_SECRET  optional, secret token from Telegram setWebhook
 */

const TZ_OFFSET_MIN = 5 * 60; // Tashkent +05:00 (—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–æ)
const COOKIE_NAME = "gsoft_session";

const PBKDF2_DEFAULT_ITER = 100000;
const PBKDF2_MAX_ITER = 100000;

function normalizePbkdf2Iter(iter) {
  const n = Number(iter);
  if (!Number.isFinite(n) || n <= 0) return PBKDF2_DEFAULT_ITER;
  return Math.floor(n);
}

const DEFAULT_CORS = [
  "https://ofis.gekto.uz",
  "https://api.ofis.gekto.uz",
  "http://localhost:5173",
  "http://localhost:3000",
];

const ROLES = ["admin", "pm", "fin", "sale", "rop"];

const TASK_STATUSES = ["new", "pause", "in_progress", "done", "canceled"];
const PROJECT_STATUSES = ["new", "tz_given", "offer_given", "in_progress", "later", "done", "review", "canceled"];
const COURSE_STATUSES = ["new", "need_call", "thinking", "enrolled", "studying", "canceled"];
const TG_DEFAULT_TIME_HHMM = "10:00";

function nowSec() {
  return Math.floor(Date.now() / 1000);
}

function jsonResp(data, status = 200, headers = {}) {
  const body = JSON.stringify(data);
  return new Response(body, {
    status,
    headers: {
      "Content-Type": "application/json; charset=utf-8",
      ...headers,
    },
  });
}

function badRequest(message, code = "bad_request") {
  return jsonResp({ ok: false, error: { code, message } }, 400);
}
function unauthorized(message = "Unauthorized") {
  return jsonResp({ ok: false, error: { code: "unauthorized", message } }, 401);
}
function forbidden(message = "Forbidden") {
  return jsonResp({ ok: false, error: { code: "forbidden", message } }, 403);
}
function notFound(message = "Not found") {
  return jsonResp({ ok: false, error: { code: "not_found", message } }, 404);
}

function parseCookies(cookieHeader) {
  const out = {};
  if (!cookieHeader) return out;
  const parts = cookieHeader.split(";");
  for (const p of parts) {
    const idx = p.indexOf("=");
    if (idx === -1) continue;
    const k = p.slice(0, idx).trim();
    const v = p.slice(idx + 1).trim();
    out[k] = v;
  }
  return out;
}

function base64url(bytes) {
  let str = "";
  for (let i = 0; i < bytes.length; i++) str += String.fromCharCode(bytes[i]);
  const b64 = btoa(str).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
  return b64;
}

function hexFromBuf(buf) {
  const bytes = new Uint8Array(buf);
  let s = "";
  for (const b of bytes) s += b.toString(16).padStart(2, "0");
  return s;
}
function bufFromHex(hex) {
  if (!hex || typeof hex !== "string" || hex.length % 2 !== 0) throw new Error("Invalid hex");
  const out = new Uint8Array(hex.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
  return out;
}

async function sha256Hex(str) {
  const enc = new TextEncoder().encode(str);
  const digest = await crypto.subtle.digest("SHA-256", enc);
  return hexFromBuf(digest);
}

async function pbkdf2Sha256Hex(password, saltHex, iterations = PBKDF2_DEFAULT_ITER, dkLen = 32) {
  const salt = bufFromHex(saltHex);
  iterations = normalizePbkdf2Iter(iterations);
  if (iterations > PBKDF2_MAX_ITER) {
    throw new Error(`Pbkdf2 failed: iteration counts above ${PBKDF2_MAX_ITER} are not supported (requested ${iterations}).`);
  }
  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    new TextEncoder().encode(password),
    "PBKDF2",
    false,
    ["deriveBits"]
  );
  const bits = await crypto.subtle.deriveBits(
    { name: "PBKDF2", hash: "SHA-256", salt, iterations },
    keyMaterial,
    dkLen * 8
  );
  return hexFromBuf(bits);
}

function getCorsOrigins(env) {
  const s = (env.CORS_ORIGINS || "").trim();
  if (!s) return DEFAULT_CORS;
  return s
    .split(",")
    .map((x) => x.trim())
    .filter(Boolean);
}

function corsHeaders(env, origin) {
  const allowed = getCorsOrigins(env);
  const ok = origin && allowed.includes(origin);
  const h = {
    Vary: "Origin",
    "Access-Control-Allow-Methods": "GET,POST,PUT,PATCH,DELETE,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, X-Requested-With",
    "Access-Control-Allow-Credentials": "true",
  };
  if (ok) h["Access-Control-Allow-Origin"] = origin;
  return h;
}

function withCors(res, env, origin) {
  if (!res) return res;
  const h = new Headers(res.headers || {});
  const cors = corsHeaders(env, origin);
  for (const [k, v] of Object.entries(cors)) h.set(k, v);
  return new Response(res.body, {
    status: res.status,
    statusText: res.statusText,
    headers: h,
  });
}

function tashkentDayBounds(tsSec = nowSec()) {
  // –ø–µ—Ä–µ–≤–æ–¥–∏–º "—Å–µ–π—á–∞—Å" –≤ "–ª–æ–∫–∞–ª—å–Ω—É—é" –¥–∞—Ç—É –¢–∞—à–∫–µ–Ω—Ç–∞ —Å –ø–æ–º–æ—â—å—é —Å–¥–≤–∏–≥–∞
  const offsetMs = TZ_OFFSET_MIN * 60 * 1000;
  const utcMs = tsSec * 1000;
  const localMs = utcMs + offsetMs;
  const d = new Date(localMs);

  const y = d.getUTCFullYear();
  const m = d.getUTCMonth();
  const day = d.getUTCDate();

  // start of day in UTC milliseconds:
  const startUtcMs = Date.UTC(y, m, day, 0, 0, 0) - offsetMs;
  const endUtcMs = startUtcMs + 24 * 60 * 60 * 1000 - 1000;

  return {
    startOfDayUtcSec: Math.floor(startUtcMs / 1000),
    endOfDayUtcSec: Math.floor(endUtcMs / 1000),
  };
}

function buildSetCookie(name, value, opts = {}) {
  const parts = [`${name}=${value}`];
  if (opts.expiresAtSec) parts.push(`Expires=${new Date(opts.expiresAtSec * 1000).toUTCString()}`);
  if (opts.maxAge != null) parts.push(`Max-Age=${opts.maxAge}`);
  parts.push(`Path=${opts.path || "/"}`);
  if (opts.domain) parts.push(`Domain=${opts.domain}`);
  if (opts.httpOnly !== false) parts.push("HttpOnly");
  if (opts.secure !== false) parts.push("Secure");
  parts.push(`SameSite=${opts.sameSite || "Lax"}`);
  return parts.join("; ");
}

function intId(x) {
  const n = Number(x);
  if (!Number.isInteger(n) || n <= 0) return null;
  return n;
}

function pick(obj, keys) {
  const out = {};
  for (const k of keys) if (obj[k] !== undefined) out[k] = obj[k];
  return out;
}

async function readJson(request) {
  const ct = request.headers.get("Content-Type") || "";
  if (!ct.toLowerCase().includes("application/json")) return null;
  try {
    return await request.json();
  } catch {
    return null;
  }
}

/** simple string getter used in users endpoints */
function str(v) {
  if (v === undefined || v === null) return "";
  return String(v).trim();
}

let _usersHasTelegramCol = null;
async function usersHasTelegramIdColumn(env) {
  if (_usersHasTelegramCol !== null) return _usersHasTelegramCol;
  const info = await env.DB.prepare("PRAGMA table_info(users)").all();
  _usersHasTelegramCol = (info.results || []).some((r) => r.name === "telegram_id");
  return _usersHasTelegramCol;
}

function tgGetEntities(msg) {
  return [
    ...(Array.isArray(msg?.entities) ? msg.entities : []),
    ...(Array.isArray(msg?.caption_entities) ? msg.caption_entities : []),
  ];
}

function tgIsTasksCommand(msg) {
  const fullText = String(msg?.text || msg?.caption || "");
  if (!fullText) return false;

  for (const ent of tgGetEntities(msg)) {
    if (ent?.type !== "bot_command") continue;
    const offset = Number(ent.offset);
    const length = Number(ent.length);
    if (!Number.isInteger(offset) || !Number.isInteger(length) || length <= 0) continue;
    const cmdText = fullText.substring(offset, offset + length);
    if (cmdText.split("@")[0].toLowerCase() === "/tasks") return true;
  }

  return /(^|\s)\/tasks(?:@\w+)?(?=\s|$)/i.test(fullText);
}

function tgGetTaskSourceText(msg) {
  if (msg?.reply_to_message) {
    const rt = msg.reply_to_message.text || msg.reply_to_message.caption;
    if (rt) return String(rt);
  }
  const text = String(msg?.text || msg?.caption || "");
  return text.replace(/\/tasks@[\w_]+/gi, "").replace(/\/tasks\b/gi, "").trim();
}

function tgExtractMentionFromEntities(msg) {
  if (!msg) return null;
  const text = String(msg.text || msg.caption || "");
  for (const ent of tgGetEntities(msg)) {
    if (ent?.type === "text_mention" && ent.user?.id) {
      return { telegramId: String(ent.user.id) };
    }
    if (ent?.type === "mention") {
      const offset = Number(ent.offset);
      const length = Number(ent.length);
      if (!Number.isInteger(offset) || !Number.isInteger(length) || length <= 0) continue;
      const mention = text.substring(offset, offset + length);
      if (mention) return { username: mention };
    }
  }
  return null;
}

function tgExtractFirstMentionFromText(text) {
  const m = String(text || "").match(/@([a-zA-Z0-9_]+)/);
  return m ? { username: `@${m[1]}` } : null;
}

function tgGetAssigneeHint(msg) {
  return (
    tgExtractMentionFromEntities(msg) ||
    tgExtractMentionFromEntities(msg?.reply_to_message) ||
    tgExtractFirstMentionFromText(msg?.text || msg?.caption || "") ||
    tgExtractFirstMentionFromText(msg?.reply_to_message?.text || msg?.reply_to_message?.caption || "")
  );
}

function cleanTaskTextForDescription(text) {
  if (!text) return "";
  let t = String(text);
  t = t.replace(/\b\d{1,2}\.\d{1,2}(?:\.\d{2,4})?\b/g, "");
  t = t.replace(/\b\d{1,2}:\d{2}\b/g, "");
  t = t.replace(/@[a-zA-Z0-9_]+/g, "");
  return t
    .split(/\r?\n/)
    .map((line) => line.replace(/\s+$/g, ""))
    .join("\n")
    .trim();
}

function tashkentParts(tsSec = nowSec()) {
  const d = new Date((tsSec + TZ_OFFSET_MIN * 60) * 1000);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth(),
    day: d.getUTCDate(),
  };
}

function toUtcSecFromTashkentLocal(year, monthZeroBased, day, hour, minute) {
  const utcMs = Date.UTC(year, monthZeroBased, day, hour, minute, 0) - TZ_OFFSET_MIN * 60 * 1000;
  return Math.floor(utcMs / 1000);
}

function parseTaskDeadlineTashkent(text) {
  const src = String(text || "");
  const dateMatch = src.match(/\b(\d{1,2}\.\d{1,2}(?:\.\d{2,4})?)\b/);
  const timeMatch = src.match(/\b(\d{1,2}:\d{2})\b/);

  const now = tashkentParts();
  const [defHour, defMinute] = TG_DEFAULT_TIME_HHMM.split(":").map((x) => Number(x));

  const parseTime = (s, fallbackHour, fallbackMinute) => {
    if (!s) return { hour: fallbackHour, minute: fallbackMinute };
    const [hRaw, mRaw] = s.split(":");
    const hour = Number(hRaw);
    const minute = Number(mRaw);
    if (!Number.isInteger(hour) || !Number.isInteger(minute) || hour < 0 || hour > 23 || minute < 0 || minute > 59) {
      return { hour: fallbackHour, minute: fallbackMinute };
    }
    return { hour, minute };
  };

  if (dateMatch?.[1]) {
    const parts = dateMatch[1].split(".");
    const day = Number(parts[0]);
    const monthZero = Number(parts[1]) - 1;
    let year = now.year;
    if (parts[2]) {
      const yRaw = Number(parts[2]);
      year = String(parts[2]).length === 2 ? 2000 + yRaw : yRaw;
    }
    if (!Number.isInteger(day) || !Number.isInteger(monthZero) || day < 1 || day > 31 || monthZero < 0 || monthZero > 11) {
      const { hour, minute } = parseTime(timeMatch?.[1], defHour, defMinute);
      return toUtcSecFromTashkentLocal(now.year, now.month, now.day + 1, hour, minute);
    }
    const { hour, minute } = parseTime(timeMatch?.[1], defHour, defMinute);
    return toUtcSecFromTashkentLocal(year, monthZero, day, hour, minute);
  }

  if (timeMatch?.[1]) {
    const { hour, minute } = parseTime(timeMatch[1], defHour, defMinute);
    return toUtcSecFromTashkentLocal(now.year, now.month, now.day, hour, minute);
  }

  return toUtcSecFromTashkentLocal(now.year, now.month, now.day + 1, defHour, defMinute);
}

function formatTashkentDateTime(tsSec) {
  const d = new Date((Number(tsSec) + TZ_OFFSET_MIN * 60) * 1000);
  const pad = (n) => String(n).padStart(2, "0");
  return `${d.getUTCFullYear()}-${pad(d.getUTCMonth() + 1)}-${pad(d.getUTCDate())} ${pad(d.getUTCHours())}:${pad(d.getUTCMinutes())}`;
}

function tgBuildMessageLink(msg) {
  const chat = msg?.chat || {};
  const chatId = chat.id;
  if (!chatId || !msg?.message_id) return "lich";

  if (chat.type === "private") return "lich";

  if (chat.username) {
    let base = `https://t.me/${chat.username}/${msg.message_id}`;
    if (msg.is_topic_message && msg.message_thread_id) base += `?thread=${msg.message_thread_id}`;
    return base;
  }

  let internalId = String(chatId);
  if (internalId.startsWith("-100")) internalId = internalId.slice(4);
  else if (internalId.startsWith("-")) internalId = internalId.slice(1);

  let base = `https://t.me/c/${internalId}/${msg.message_id}`;
  if (msg.is_topic_message && msg.message_thread_id) base += `?thread=${msg.message_thread_id}`;
  return base;
}

async function findUserByTelegramId(env, tgId) {
  const hasTg = await usersHasTelegramIdColumn(env);
  if (!hasTg) return null;
  if (!/^\d+$/.test(String(tgId || ""))) return null;
  return env.DB.prepare(
    `SELECT id, full_name, login, role, telegram_id
     FROM users
     WHERE is_active=1 AND telegram_id=?
     LIMIT 1`
  )
    .bind(String(tgId))
    .first();
}

async function findUserByMention(env, mention) {
  if (!mention) return null;
  const uname = String(mention).replace(/^@+/, "").trim().toLowerCase();
  if (!uname) return null;
  return env.DB.prepare(
    `SELECT id, full_name, login, role, telegram_id
     FROM users
     WHERE is_active=1
       AND (LOWER(login)=? OR LOWER(TRIM(login,'@'))=?)
     LIMIT 1`
  )
    .bind(uname, uname)
    .first();
}

async function tgApiCall(env, method, payload) {
  const token = String(env.TG_BOT_TOKEN || "").trim();
  if (!token) return null;
  const url = `https://api.telegram.org/bot${token}/${method}`;
  try {
    const res = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload || {}),
    });
    return await res.text();
  } catch {
    return null;
  }
}

async function tgGetUserIdByUsername(env, username) {
  const token = String(env.TG_BOT_TOKEN || "").trim();
  const uname = String(username || "").replace(/^@+/, "").trim();
  if (!token || !uname) return null;
  const url = `https://api.telegram.org/bot${token}/getChat?chat_id=@${encodeURIComponent(uname)}`;
  try {
    const res = await fetch(url, { method: "GET" });
    const data = await res.json();
    if (!data || !data.ok || !data.result || !data.result.id) return null;
    return String(data.result.id);
  } catch {
    return null;
  }
}

async function tgSendMessage(env, chatId, text, threadId) {
  if (!chatId || !text) return;
  const payload = { chat_id: chatId, text: String(text) };
  if (threadId) payload.message_thread_id = threadId;
  await tgApiCall(env, "sendMessage", payload);
}

async function tgSetReaction(env, chatId, messageId, emoji = "ü´°") {
  if (!chatId || !messageId) return;
  await tgApiCall(env, "setMessageReaction", {
    chat_id: chatId,
    message_id: messageId,
    reaction: [{ type: "emoji", emoji }],
    is_big: false,
  });
}

const tgRecentMessages = new Map();
function tgAlreadyProcessed(chatId, messageId) {
  if (!chatId || !messageId) return false;
  const now = Date.now();
  const key = `${chatId}_${messageId}`;
  const prev = tgRecentMessages.get(key);
  if (prev && now - prev < 60 * 60 * 1000) return true;
  tgRecentMessages.set(key, now);
  if (tgRecentMessages.size > 2000) {
    for (const [k, ts] of tgRecentMessages) {
      if (now - ts > 60 * 60 * 1000) tgRecentMessages.delete(k);
    }
  }
  return false;
}

async function handleTelegramWebhook(env, request) {
  const secret = String(env.TG_WEBHOOK_SECRET || "").trim();
  if (secret) {
    const got = String(request.headers.get("x-telegram-bot-api-secret-token") || "");
    if (!got || got !== secret) return forbidden("Invalid webhook secret");
  }

  const update = await readJson(request);
  if (!update) return jsonResp({ ok: true }, 200);
  const msg = update.message;
  if (!msg) return jsonResp({ ok: true }, 200);
  if (!tgIsTasksCommand(msg)) return jsonResp({ ok: true }, 200);

  const chatId = msg.chat?.id;
  const messageId = msg.message_id;
  const threadId = msg.is_topic_message && msg.message_thread_id ? msg.message_thread_id : null;

  if (tgAlreadyProcessed(chatId, messageId)) return jsonResp({ ok: true, duplicate: true }, 200);

  const creatorTgId = msg.from?.id ? String(msg.from.id) : "";
  const creator = await findUserByTelegramId(env, creatorTgId);
  if (!creator) {
    await tgSendMessage(
      env,
      chatId,
      "–ù–µ –Ω–∞–π–¥–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ —Å–∏—Å—Ç–µ–º–µ –ø–æ –≤–∞—à–µ–º—É Telegram ID. –ó–∞–ø–æ–ª–Ω–∏—Ç–µ `telegram_id` –≤ Users.",
      threadId
    );
    return jsonResp({ ok: true, skipped: "creator_not_found" }, 200);
  }

  let assignee = null;
  const hint = tgGetAssigneeHint(msg);
  if (hint?.telegramId) assignee = await findUserByTelegramId(env, hint.telegramId);
  if (!assignee && hint?.username) {
    const tgId = await tgGetUserIdByUsername(env, hint.username);
    if (tgId) assignee = await findUserByTelegramId(env, tgId);
  }
  if (!assignee && hint?.username) assignee = await findUserByMention(env, hint.username);
  if (!assignee) assignee = creator;

  const sourceText = tgGetTaskSourceText(msg);
  const combinedText = `${msg.text || msg.caption || ""}\n${msg.reply_to_message ? msg.reply_to_message.text || msg.reply_to_message.caption || "" : ""}`;
  const deadlineAt = parseTaskDeadlineTashkent(combinedText);
  const cleaned = cleanTaskTextForDescription(sourceText);
  const descriptionBase = cleaned || sourceText || "Task from Telegram";
  const title = (descriptionBase.split(/\r?\n/).map((x) => x.trim()).find(Boolean) || "Task from Telegram").slice(0, 120);
  const messageLink = tgBuildMessageLink(msg);
  const description = messageLink && messageLink !== "lich" ? `${descriptionBase}\n\nSource: ${messageLink}` : descriptionBase;

  const res = await env.DB.prepare(
    `INSERT INTO tasks(title, description, assignee_user_id, project_id, status, deadline_at, is_active, created_by)
     VALUES(?,?,?,?, 'new', ?, 1, ?)`
  )
    .bind(title, String(description).trim(), assignee.id, null, deadlineAt, creator.id)
    .run();

  const taskId = res?.meta?.last_row_id;
  await tgSendMessage(
    env,
    chatId,
    `‚úÖ –ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞\n#${taskId}\nDeadline: ${formatTashkentDateTime(deadlineAt)}\n–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π: ${assignee.full_name || assignee.login || assignee.id}`,
    threadId
  );
  await tgSetReaction(env, chatId, messageId, "ü´°");

  return jsonResp({ ok: true, data: { id: taskId } }, 200);
}

/** normalize phone for stable duplicate checks */
function normalizePhone(v) {
  const raw = str(v);
  if (!raw) return "";
  const hasPlus = raw.startsWith("+");
  const digits = raw.replace(/\D/g, "");
  if (!digits) return "";
  return `${hasPlus ? "+" : ""}${digits}`;
}

/** digits-only key for comparing phones regardless of separators/plus */
function phoneDigits(v) {
  return normalizePhone(v).replace(/\D/g, "");
}

/** hash password for users table (pbkdf2_sha256) */
async function hashPassword(password, iterations = PBKDF2_DEFAULT_ITER) {
  const saltBytes = new Uint8Array(16);
  crypto.getRandomValues(saltBytes);
  const saltHex = Array.from(saltBytes).map((b) => b.toString(16).padStart(2, "0")).join("");
  const iter = normalizePbkdf2Iter(iterations);
  const algo = "pbkdf2_sha256";
  const hashHex = await pbkdf2Sha256Hex(String(password), saltHex, iter, 32);
  return { saltHex, hashHex, iter, algo };
}

/** cleanup: after midnight, any in_progress tasks should drop to pause + close open time logs */
async function autoPauseOvernight(env) {
  const ts = nowSec();
  const { startOfDayUtcSec } = tashkentDayBounds(ts);
  const endOfYesterday = startOfDayUtcSec - 1;

  // Close any open logs that started before today (safety)
  await env.DB.batch([
    env.DB.prepare(
      `UPDATE task_time_logs
       SET end_at = ?
       WHERE end_at IS NULL AND start_at < ?`
    ).bind(endOfYesterday, startOfDayUtcSec),

    env.DB.prepare(
      `UPDATE tasks
       SET status = 'pause'
       WHERE is_active = 1
         AND status = 'in_progress'
         AND updated_at < ?`
    ).bind(startOfDayUtcSec),
  ]);
}

async function getSessionUser(env, request) {
  const cookies = parseCookies(request.headers.get("Cookie") || "");
  const token = cookies[COOKIE_NAME];
  if (!token) return null;

  const tokenHash = await sha256Hex(token);
  const ts = nowSec();

  const row = await env.DB.prepare(
    `SELECT s.user_id, s.expires_at, u.full_name, u.login, u.role, u.is_active
     FROM sessions s
     JOIN users u ON u.id = s.user_id
     WHERE s.token_hash_hex = ?`
  )
    .bind(tokenHash)
    .first();

  if (!row) return null;
  if (row.is_active !== 1) return null;
  if (row.expires_at <= ts) return null;

  // touch last_seen
  await env.DB.prepare(`UPDATE sessions SET last_seen_at = ? WHERE user_id = ?`)
    .bind(ts, row.user_id)
    .run();

  return {
    id: row.user_id,
    full_name: row.full_name,
    login: row.login,
    role: row.role,
    expires_at: row.expires_at,
  };
}

function requireRole(user, allowed) {
  if (!user) return false;
  if (!allowed || allowed.length === 0) return true;
  return allowed.includes(user.role);
}

/** RBAC helpers */
function canSeeTask(user, taskRow) {
  if (!user) return false;
  if (user.role === "admin" || user.role === "rop") return true;
  if (user.role === "fin" || user.role === "sale") {
    return taskRow.assignee_user_id === user.id;
  }
  if (user.role === "pm") {
    // PM: —Å–≤–æ–∏ –∑–∞–¥–∞—á–∏ + –≤—Å–µ –∑–∞–¥–∞—á–∏ —Å–≤–æ–∏—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤
    if (taskRow.assignee_user_id === user.id) return true;
    return taskRow.project_pm_user_id === user.id;
  }
  return taskRow.assignee_user_id === user.id;
}

function canSeeProject(user, projectRow) {
  if (!user) return false;
  if (user.role === "admin" || user.role === "rop") return true;
  if (user.role === "pm") return projectRow.pm_user_id === user.id;
  if (user.role === "fin") return projectRow._fin_has_task === 1;
  // sale: –ø–æ –¢–ó –Ω–µ –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–æ—Å—Ç—É–ø –∫ –ø—Ä–æ–µ–∫—Ç–∞–º
  return false;
}

function projectAmountVisible(user) {
  return user && (user.role === "admin" || user.role === "rop");
}
function courseAmountVisible(user) {
  return user && (user.role === "admin" || user.role === "rop" || user.role === "sale");
}

async function ensurePaidRequiredForCourseStatus(bodyStatus, paidAmount) {
  if (bodyStatus === "enrolled" || bodyStatus === "studying") {
    if (paidAmount === null || paidAmount === undefined || Number.isNaN(Number(paidAmount))) {
      return "paid_amount_required";
    }
  }
  return null;
}

async function createSession(env, userId) {
  const ts = nowSec();
  const { endOfDayUtcSec } = tashkentDayBounds(ts);

  const tokenBytes = new Uint8Array(32);
  crypto.getRandomValues(tokenBytes);
  const token = base64url(tokenBytes);
  const tokenHash = await sha256Hex(token);

  // 1 session per user: upsert semantics
  await env.DB.batch([
    env.DB.prepare(`DELETE FROM sessions WHERE user_id = ?`).bind(userId),
    env.DB.prepare(
      `INSERT INTO sessions(user_id, token_hash_hex, expires_at, created_at, last_seen_at)
       VALUES(?,?,?,?,?)`
    ).bind(userId, tokenHash, endOfDayUtcSec, ts, ts),
  ]);

  return { token, expires_at: endOfDayUtcSec };
}

async function deleteSession(env, request) {
  const cookies = parseCookies(request.headers.get("Cookie") || "");
  const token = cookies[COOKIE_NAME];
  if (!token) return;

  const tokenHash = await sha256Hex(token);
  await env.DB.prepare(`DELETE FROM sessions WHERE token_hash_hex = ?`).bind(tokenHash).run();
}

/** minimal input guard */
function requireFields(obj, fields) {
  for (const f of fields) {
    if (obj[f] === undefined || obj[f] === null || obj[f] === "") return f;
  }
  return null;
}

async function listUsers(env) {
  const hasTg = await usersHasTelegramIdColumn(env);
  const res = await env.DB
    .prepare(
      `SELECT id, full_name, phone${hasTg ? ", telegram_id" : ""}, login, role, is_active, created_at, updated_at, last_login_at
       FROM users
       ORDER BY id DESC`
    )
    .all();
  return res.results || [];
}


/** tasks query: includes assignee name, project name, pm id; includes spent_seconds */
async function queryTasksKanban(env, user, filters) {
  // filters: assignee_user_id (admin only), project_id
  const ts = nowSec();

  // Base query pulls pm_user_id for project to support PM visibility
  // Also compute spent_seconds with a subquery
  let sql = `
    SELECT
      t.id, t.title, t.description, t.assignee_user_id, t.project_id, t.status, t.deadline_at,
      t.cancel_reason, t.is_active, t.created_by, t.created_at, t.updated_at,
      u.full_name AS assignee_name,
      cu.full_name AS created_by_name,
      p.status AS project_status,
      p.pm_user_id AS project_pm_user_id,
      c.company_name AS project_company_name,
      st.name_ru AS service_name_ru, st.name_uz AS service_name_uz, st.name_en AS service_name_en,
      COALESCE((
        SELECT SUM(COALESCE(l.end_at, ?) - l.start_at)
        FROM task_time_logs l
        WHERE l.task_id = t.id
      ),0) AS spent_seconds
    FROM tasks t
    JOIN users u ON u.id = t.assignee_user_id
    JOIN users cu ON cu.id = t.created_by
    LEFT JOIN projects p ON p.id = t.project_id
    LEFT JOIN clients c ON c.id = p.client_id
    LEFT JOIN service_types st ON st.id = p.service_type_id
    WHERE t.is_active = 1
  `;

  const binds = [ts];

  // Role-based visibility constraints
  if (user.role === "admin" || user.role === "rop") {
    // no constraint
  } else if (user.role === "pm") {
    sql += ` AND (t.assignee_user_id = ? OR p.pm_user_id = ?)`;
    binds.push(user.id, user.id);
  } else {
    // fin / sale / others: —Ç–æ–ª—å–∫–æ —Å–≤–æ–∏ –∑–∞–¥–∞—á–∏
    sql += ` AND t.assignee_user_id = ?`;
    binds.push(user.id);
  }

  if (filters.project_id) {
    sql += ` AND t.project_id = ?`;
    binds.push(filters.project_id);
  }

  if (filters.assignee_user_id) {
    // only admin/rop can filter by someone else; others forced to themselves
    if (user.role === "admin" || user.role === "rop") {
      sql += ` AND t.assignee_user_id = ?`;
      binds.push(filters.assignee_user_id);
    } else {
      sql += ` AND t.assignee_user_id = ?`;
      binds.push(user.id);
    }
  }

  sql += ` ORDER BY t.updated_at DESC`;

  const res = await env.DB.prepare(sql).bind(...binds).all();
  return res.results || [];
}

async function queryProjectsKanban(env, user, filters) {
  // filters: pm_user_id, service_type_id
  const ts = nowSec();
  let sql = `
    SELECT
      p.id, p.client_id, p.service_type_id, p.meeting_at, p.deadline_at,
      p.amount, p.currency, p.pm_user_id, p.status, p.review, p.comment, p.cancel_reason,
      p.is_active, p.created_by, p.created_at, p.updated_at,

      c.company_name,
      c.full_name AS owner_full_name, c.phone1 AS owner_phone1, c.phone2 AS owner_phone2,

      st.name_ru AS service_name_ru, st.name_uz AS service_name_uz, st.name_en AS service_name_en,

      u.full_name AS pm_name,
      cu.full_name AS created_by_name,

      -- ‚úÖ tasks stats (–¥–ª—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –Ω–∞ –∫–∞—Ä—Ç–æ—á–∫–µ –ø—Ä–æ–µ–∫—Ç–∞)
      COALESCE((SELECT COUNT(1)
                FROM tasks t
                WHERE t.is_active = 1 AND t.project_id = p.id), 0) AS tasks_total,

      COALESCE((SELECT COUNT(1)
                FROM tasks t
                WHERE t.is_active = 1 AND t.project_id = p.id AND t.status = 'done'), 0) AS tasks_done,

      CASE WHEN EXISTS (
        SELECT 1 FROM tasks t
        WHERE t.is_active=1 AND t.project_id=p.id AND t.assignee_user_id=?
      ) THEN 1 ELSE 0 END AS _fin_has_task

    FROM projects p
    JOIN clients c ON c.id = p.client_id
    JOIN service_types st ON st.id = p.service_type_id
    JOIN users u ON u.id = p.pm_user_id
    JOIN users cu ON cu.id = p.created_by
    WHERE p.is_active = 1
  `;

  const binds = [user.id];

  // Role-based
  if (user.role === "admin" || user.role === "rop") {
    // ok
  } else if (user.role === "pm") {
    sql += ` AND p.pm_user_id = ?`;
    binds.push(user.id);
  } else if (user.role === "fin") {
    sql += ` AND EXISTS (
      SELECT 1 FROM tasks t
      WHERE t.is_active=1 AND t.project_id=p.id AND t.assignee_user_id=?
    )`;
    binds.push(user.id);
  } else {
    // sale/other no projects
    sql += ` AND 1=0`;
  }

  if (filters.pm_user_id) {
    if (user.role === "admin" || user.role === "rop") {
      sql += ` AND p.pm_user_id = ?`;
      binds.push(filters.pm_user_id);
    }
  }
  if (filters.service_type_id) {
    sql += ` AND p.service_type_id = ?`;
    binds.push(filters.service_type_id);
  }

  sql += ` ORDER BY p.updated_at DESC`;

  const res = await env.DB.prepare(sql).bind(...binds).all();
  let rows = res.results || [];

  // hide amount for non admin/rop
  if (!projectAmountVisible(user)) {
    rows = rows.map((r) => {
      const copy = { ...r };
      delete copy.amount;
      delete copy.currency;
      return copy;
    });
  }

  return rows;
}


async function queryCourseLeadsKanban(env, user, filters) {
  // accessible for admin/rop/sale
  if (!(user.role === "admin" || user.role === "rop" || user.role === "sale")) return [];

  let sql = `
    SELECT
      cl.id, cl.lead_client_id, cl.company_id, cl.course_type_id,
      cl.course_price, cl.course_start_date, cl.currency,
      cl.agreed_amount, cl.paid_amount, cl.status, cl.comment, cl.cancel_reason,
      cl.is_active, cl.created_by, cl.created_at, cl.updated_at,

      lead.full_name AS lead_full_name,
      lead.phone1 AS lead_phone1,
      lead.comment AS lead_comment,
      lead.city_id AS lead_city_id,
      lead.source_id AS lead_source_id,
      lead.sphere_id AS lead_sphere_id,
      COALESCE(dc.name_uz, dc.name_ru, dc.name_en) AS lead_city_name,
      COALESCE(ds.name_uz, ds.name_ru, ds.name_en) AS lead_source_name,
      COALESCE(dsp.name_uz, dsp.name_ru, dsp.name_en) AS lead_sphere_name,
      comp.company_name AS company_name,

      ct.name AS course_type_name,
      cu.full_name AS created_by_name
    FROM course_leads cl
    JOIN clients lead ON lead.id = cl.lead_client_id
    LEFT JOIN clients comp ON comp.id = cl.company_id
    LEFT JOIN dict_cities dc ON dc.id = lead.city_id
    LEFT JOIN dict_sources ds ON ds.id = lead.source_id
    LEFT JOIN dict_spheres dsp ON dsp.id = lead.sphere_id
    JOIN course_types ct ON ct.id = cl.course_type_id
    JOIN users cu ON cu.id = cl.created_by
    WHERE cl.is_active = 1
  `;
  const binds = [];

  if (filters.company_id) {
    sql += ` AND cl.company_id = ?`;
    binds.push(filters.company_id);
  }
  if (filters.course_type_id) {
    sql += ` AND cl.course_type_id = ?`;
    binds.push(filters.course_type_id);
  }
  sql += ` ORDER BY cl.updated_at DESC`;

  const res = await env.DB.prepare(sql).bind(...binds).all();
  let rows = res.results || [];

  // sale sees course amounts; ok. If ever needed to hide, do it here.
  if (!courseAmountVisible(user)) {
    rows = rows.map((r) => {
      const copy = { ...r };
      delete copy.course_price;
      delete copy.agreed_amount;
      delete copy.paid_amount;
      delete copy.currency;
      return copy;
    });
  }
  return rows;
}

/** Clients list by type with RBAC:
 * - admin/rop/sale: both
 * - pm: only companies
 * - fin: no clients list
 */
async function queryClients(env, user, type, q) {
  if (user.role === "fin") return [];
  if (user.role === "pm" && type !== "company") return [];

  let sql = `
    SELECT
      id, type, company_name, full_name, phone1, phone2,
      city_id, source_id, sphere_id, comment, tg_group_link, company_id,
      is_active, created_by, created_at, updated_at
    FROM clients
    WHERE is_active = 1
  `;
  const binds = [];

  if (type) {
    sql += ` AND type = ?`;
    binds.push(type);
  }

  // RBAC: pm only companies already handled; sale/admin/rop ok
  if (q && q.trim()) {
    sql += ` AND (
      lower(full_name) LIKE ? OR
      lower(COALESCE(company_name,'')) LIKE ? OR
      phone1 LIKE ? OR
      COALESCE(phone2,'') LIKE ?
    )`;
    const s = `%${q.trim().toLowerCase()}%`;
    binds.push(s, s, `%${q.trim()}%`, `%${q.trim()}%`);
  }

  sql += ` ORDER BY updated_at DESC LIMIT 500`;

  const res = await env.DB.prepare(sql).bind(...binds).all();
  return res.results || [];
}

async function getClientCard(env, user, clientId) {
  if (user.role === "fin") return null;

  const client = await env.DB.prepare(
    `SELECT
      id, type, company_name, full_name, phone1, phone2,
      city_id, source_id, sphere_id, comment, tg_group_link, company_id,
      is_active, created_by, created_at, updated_at
     FROM clients
     WHERE id = ? AND is_active = 1`
  )
    .bind(clientId)
    .first();

  if (!client) return null;

  // RBAC: pm only companies
  if (user.role === "pm" && client.type !== "company") return null;

  const data = { client };

  if (client.type === "company") {
    // lists inside company card: course leads + projects
    const courseLeads = await env.DB.prepare(
      `SELECT cl.id, cl.status, cl.agreed_amount, cl.paid_amount,
              ct.name AS course_type_name,
              lead.full_name AS lead_full_name
       FROM course_leads cl
       JOIN course_types ct ON ct.id = cl.course_type_id
       JOIN clients lead ON lead.id = cl.lead_client_id
       WHERE cl.is_active=1 AND cl.company_id = ?
       ORDER BY cl.updated_at DESC LIMIT 200`
    )
      .bind(clientId)
      .all();

    const projects = await env.DB.prepare(
      `SELECT p.id, p.status, p.pm_user_id, u.full_name AS pm_name,
              p.amount, p.currency,
              st.name_ru AS service_name_ru, st.name_uz AS service_name_uz, st.name_en AS service_name_en
       FROM projects p
       JOIN users u ON u.id = p.pm_user_id
       JOIN service_types st ON st.id = p.service_type_id
       WHERE p.is_active=1 AND p.client_id = ?
       ORDER BY p.updated_at DESC LIMIT 200`
    )
      .bind(clientId)
      .all();

    let projRows = projects.results || [];
    if (!projectAmountVisible(user)) {
      projRows = projRows.map((r) => {
        const copy = { ...r };
        delete copy.amount;
        delete copy.currency;
        return copy;
      });
    }

    let clRows = courseLeads.results || [];
    if (!courseAmountVisible(user)) {
      clRows = clRows.map((r) => {
        const copy = { ...r };
        delete copy.agreed_amount;
        delete copy.paid_amount;
        return copy;
      });
    }

    data.course_leads = clRows;
    data.projects = projRows;
  }

  return data;
}

async function listSettingsAll(env) {
  const [theme, cities, spheres, sources, courseTypes, serviceTypes] = await Promise.all([
    env.DB.prepare(`SELECT key, value_json, updated_at FROM app_settings WHERE key='theme'`).first(),
    env.DB.prepare(`SELECT * FROM dict_cities WHERE is_active=1 ORDER BY sort, id DESC`).all(),
    env.DB.prepare(`SELECT * FROM dict_spheres WHERE is_active=1 ORDER BY sort, id DESC`).all(),
    env.DB.prepare(`SELECT * FROM dict_sources WHERE is_active=1 ORDER BY sort, id DESC`).all(),
    env.DB.prepare(`SELECT * FROM course_types WHERE is_active=1 ORDER BY sort, id DESC`).all(),
    env.DB.prepare(`SELECT * FROM service_types WHERE is_active=1 ORDER BY sort, id DESC`).all(),
  ]);

  return {
    theme: theme ? { key: theme.key, value: JSON.parse(theme.value_json || "{}"), updated_at: theme.updated_at } : null,
    dict_cities: cities.results || [],
    dict_spheres: spheres.results || [],
    dict_sources: sources.results || [],
    course_types: courseTypes.results || [],
    service_types: serviceTypes.results || [],
  };
}

async function handleAuthLogin(env, request, origin) {
  const body = await readJson(request);
  if (!body) return badRequest("Expected JSON");

  const miss = requireFields(body, ["login", "password"]);
  if (miss) return badRequest(`Missing: ${miss}`);

  const login = String(body.login).trim();
  const password = String(body.password);

  const user = await env.DB.prepare(
    `SELECT id, full_name, login, role, is_active, pass_algo, pass_salt_hex, pass_hash_hex, pass_iter
     FROM users
     WHERE login = ?`
  )
    .bind(login)
    .first();

  if (!user || user.is_active !== 1) return unauthorized("–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å");

  const algo = user.pass_algo || "pbkdf2_sha256";
  if (algo !== "pbkdf2_sha256") return unauthorized("Unsupported password algo");

  const hashHex = await pbkdf2Sha256Hex(password, user.pass_salt_hex, normalizePbkdf2Iter(user.pass_iter), 32);
  if (hashHex !== String(user.pass_hash_hex)) return unauthorized("–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å");

  // create session until end of day tashkent
  const sess = await createSession(env, user.id);

  // update last_login_at
  await env.DB.prepare(`UPDATE users SET last_login_at = ? WHERE id = ?`)
    .bind(nowSec(), user.id)
    .run();

  const cookieDomain = (env.COOKIE_DOMAIN || "").trim() || undefined;
  const setCookie = buildSetCookie(COOKIE_NAME, sess.token, {
    expiresAtSec: sess.expires_at,
    domain: cookieDomain,
    httpOnly: true,
    secure: true,
    sameSite: "Lax",
    path: "/",
  });

  const headers = {
    ...corsHeaders(env, origin),
    "Set-Cookie": setCookie,
  };

  return jsonResp(
    {
      ok: true,
      data: {
        user: { id: user.id, full_name: user.full_name, login: user.login, role: user.role },
        session_expires_at: sess.expires_at,
      },
    },
    200,
    headers
  );
}

async function handleAuthLogout(env, request, origin) {
  await deleteSession(env, request);

  const cookieDomain = (env.COOKIE_DOMAIN || "").trim() || undefined;
  const clearCookie = buildSetCookie(COOKIE_NAME, "", {
    expiresAtSec: 0,
    maxAge: 0,
    domain: cookieDomain,
    httpOnly: true,
    secure: true,
    sameSite: "Lax",
    path: "/",
  });

  return jsonResp({ ok: true }, 200, { ...corsHeaders(env, origin), "Set-Cookie": clearCookie });
}

/** users: admin only */
async function handleUsers(env, user, request, origin, segments) {
  const method = request.method;
  const id = segments[2] ? intId(segments[2]) : null;

  const normTelegramId = (v) => {
    if (v === undefined || v === null) return null;
    const s = String(v).trim();
    if (!s) return null;
    if (!/^\d+$/.test(s)) throw new Error("Invalid telegram_id");
    const n = Number(s);
    if (!Number.isSafeInteger(n) || n <= 0) throw new Error("Invalid telegram_id");
    return n;
  };

  // ‚úÖ GET /api/users ‚Äî –¥–æ—Å—Ç—É–ø–Ω–æ –≤—Å–µ–º –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–º (–¥–ª—è –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è –∑–∞–¥–∞—á)
  if (method === "GET" && !id) {
    if (!user) return forbidden("No auth");
    if (user.role === "admin") {
      const rows = await listUsers(env);
      return jsonResp({ ok: true, data: rows }, 200, corsHeaders(env, origin));
    }
    const rows = await env.DB
      .prepare(
        `SELECT id, full_name, login, role, is_active
         FROM users
         WHERE is_active=1
         ORDER BY full_name ASC`
      )
      .all();
    return jsonResp({ ok: true, data: rows.results || [] }, 200, corsHeaders(env, origin));
  }

  // from here: admin-only routes
  if (!requireRole(user, ["admin"])) return forbidden("Only admin");

  const hasTgCol = await usersHasTelegramIdColumn(env);

  // ‚úÖ POST /api/users ‚Äî admin only
  if (method === "POST" && !id) {
    const body = await readJson(request);
    if (!body) return badRequest("Expected JSON");

    const full_name = str(body.full_name);
    const phone = str(body.phone);
    const login = str(body.login);
    const role = str(body.role);
    const new_password = str(body.new_password);

    if (!full_name || !login || !role || !new_password) return badRequest("Missing fields");
    if (!["admin", "pm", "fin", "sale", "rop"].includes(role)) return badRequest("Invalid role");

    let telegram_id = null;
    if (hasTgCol) {
      try {
        telegram_id = normTelegramId(body.telegram_id);
      } catch {
        return badRequest("Invalid telegram_id");
      }
    } else {
      // if client sends telegram_id but DB doesn't support it -> explicit hint
      if (body.telegram_id !== undefined && String(body.telegram_id).trim() !== "") {
        return badRequest("DB schema has no telegram_id column. Run D1 migration to add it.");
      }
    }

    const { saltHex, hashHex, iter, algo } = await hashPassword(new_password);

    try {
      const stmt = hasTgCol
        ? `INSERT INTO users(full_name, phone, telegram_id, login, role, pass_algo, pass_salt_hex, pass_hash_hex, pass_iter, is_active)
           VALUES(?,?,?,?,?,?,?,?,?,1)`
        : `INSERT INTO users(full_name, phone, login, role, pass_algo, pass_salt_hex, pass_hash_hex, pass_iter, is_active)
           VALUES(?,?,?,?,?,?,?,?,1)`;

      const binds = hasTgCol
        ? [full_name, phone || null, telegram_id, login, role, algo, saltHex, hashHex, iter]
        : [full_name, phone || null, login, role, algo, saltHex, hashHex, iter];

      const r = await env.DB.prepare(stmt).bind(...binds).run();
      return jsonResp({ ok: true, id: r.meta.last_row_id }, 200, corsHeaders(env, origin));
    } catch {
      return badRequest("Create failed (duplicate login/telegram_id?)");
    }
  }

  // ‚úÖ PUT /api/users/:id ‚Äî admin only
  if (method === "PUT" && id) {
    const body = await readJson(request);
    if (!body) return badRequest("Expected JSON");

    const allowed = pick(body, ["full_name", "phone", "telegram_id", "login", "role", "is_active"]);
    if (!hasTgCol) delete allowed.telegram_id;

    if (!Object.keys(allowed).length) return badRequest("Nothing to update");
    if (allowed.role && !["admin", "pm", "fin", "sale", "rop"].includes(allowed.role)) return badRequest("Invalid role");

    if ("telegram_id" in allowed) {
      try {
        allowed.telegram_id = normTelegramId(allowed.telegram_id);
      } catch {
        return badRequest("Invalid telegram_id");
      }
    }

    const set = Object.keys(allowed).map((k) => `${k}=?`).join(", ");
    const binds = Object.keys(allowed).map((k) => {
      const v = allowed[k];
      if (k === "is_active") return Number(v) ? 1 : 0;
      return v === "" ? null : v;
    });

    try {
      await env.DB.prepare(`UPDATE users SET ${set} WHERE id = ?`).bind(...binds, id).run();
      return jsonResp({ ok: true }, 200, corsHeaders(env, origin));
    } catch {
      return badRequest("Update failed (duplicate login/telegram_id?)");
    }
  }

  // ‚úÖ POST /api/users/:id/reset_password ‚Äî admin only
  if (method === "POST" && id && segments[3] === "reset_password") {
    const body = await readJson(request);
    if (!body) return badRequest("Expected JSON");

    const new_password = str(body.new_password);
    if (!new_password) return badRequest("Missing new_password");

    const { saltHex, hashHex, iter, algo } = await hashPassword(new_password);
    await env.DB
      .prepare(`UPDATE users SET pass_algo=?, pass_salt_hex=?, pass_hash_hex=?, pass_iter=? WHERE id=?`)
      .bind(algo, saltHex, hashHex, iter, id)
      .run();

    await env.DB.prepare("DELETE FROM sessions WHERE user_id=?").bind(id).run();
    return jsonResp({ ok: true }, 200, corsHeaders(env, origin));
  }

  return notFound();
}



/** settings: admin only */
async function handleSettings(env, user, request, origin, segments) {
  const method = request.method;
  const isAdmin = requireRole(user, ["admin"]);
  const isRead = method === "GET";

  // GET —Ä–∞–∑—Ä–µ—à–∞–µ–º –≤—Å–µ–º –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–º (–Ω—É–∂–Ω–æ –¥–ª—è Projects/Clients),
  // –∞ –ª—é–±—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è ‚Äî —Ç–æ–ª—å–∫–æ admin.
  if (!isRead && !isAdmin) return forbidden("Only admin");


  // GET /api/settings/all
  if (method === "GET" && segments[2] === "all") {
    const data = await listSettingsAll(env);
    return jsonResp({ ok: true, data }, 200, corsHeaders(env, origin));
  }

  // theme: GET/PUT /api/settings/theme
  if (segments[2] === "theme") {
    if (method === "GET") {
      const row = await env.DB.prepare(`SELECT key, value_json, updated_at FROM app_settings WHERE key='theme'`).first();
      const data = row ? { key: row.key, value: JSON.parse(row.value_json || "{}"), updated_at: row.updated_at } : null;
      return jsonResp({ ok: true, data }, 200, corsHeaders(env, origin));
    }
    if (method === "PUT") {
      const body = await readJson(request);
      if (!body) return badRequest("Expected JSON");
      // accept anything JSON-ish, store as string
      const value_json = JSON.stringify(body.value ?? body);
      await env.DB.prepare(`INSERT OR REPLACE INTO app_settings(key,value_json,updated_at) VALUES('theme',?,?)`)
        .bind(value_json, nowSec())
        .run();
      return jsonResp({ ok: true }, 200, corsHeaders(env, origin));
    }
  }

  // dict CRUD helper
  async function dictCrud(table, is3lang) {
    if (method !== "GET" && !isAdmin) return forbidden("Only admin");
    const id = segments[3] ? intId(segments[3]) : null;
    const body = await readJson(request);

    if (method === "GET" && !id) {
      const rows = await env.DB.prepare(`SELECT * FROM ${table} WHERE is_active=1 ORDER BY sort, id DESC`).all();
      return jsonResp({ ok: true, data: rows.results || [] }, 200, corsHeaders(env, origin));
    }

    if (method === "POST" && !id) {
      if (!body) return badRequest("Expected JSON");
      if (is3lang) {
        const miss = requireFields(body, ["name_ru", "name_uz", "name_en"]);
        if (miss) return badRequest(`Missing: ${miss}`);
        const sort = body.sort == null ? 1000 : Number(body.sort);
        await env.DB.prepare(
          `INSERT INTO ${table}(name_ru,name_uz,name_en,sort,is_active) VALUES(?,?,?,?,1)`
        )
          .bind(String(body.name_ru).trim(), String(body.name_uz).trim(), String(body.name_en).trim(), sort)
          .run();
      } else {
        // course_types: name, start_date, price, currency, sort
        const miss = requireFields(body, ["name"]);
        if (miss) return badRequest(`Missing: ${miss}`);
        const sort = body.sort == null ? 1000 : Number(body.sort);
        const start_date = body.start_date == null ? null : Number(body.start_date);
        const price = body.price == null ? 0 : Number(body.price);
        const currency = body.currency ? String(body.currency) : "UZS";
        await env.DB.prepare(
          `INSERT INTO ${table}(name,start_date,price,currency,sort,is_active) VALUES(?,?,?,?,?,1)`
        )
          .bind(String(body.name).trim(), start_date, price, currency, sort)
          .run();
      }
      return jsonResp({ ok: true }, 200, corsHeaders(env, origin));
    }

    if (!id) return notFound();

    if (method === "PUT") {
      if (!isAdmin) return forbidden("Only admin");
      if (!body) return badRequest("Expected JSON");
      if (is3lang) {
        const allowed = pick(body, ["name_ru", "name_uz", "name_en", "sort", "is_active"]);
        const keys = Object.keys(allowed);
        if (!keys.length) return badRequest("No fields");
        const set = keys.map((k) => `${k}=?`).join(",");
        const binds = keys.map((k) => {
          const v = allowed[k];
          if (k.startsWith("name_")) return v == null ? null : String(v).trim();
          if (k === "sort") return v == null ? 1000 : Number(v);
          if (k === "is_active") return Number(v) ? 1 : 0;
          return v;
        });
        await env.DB.prepare(`UPDATE ${table} SET ${set} WHERE id=?`).bind(...binds, id).run();
      } else {
        const allowed = pick(body, ["name", "start_date", "price", "currency", "sort", "is_active"]);
        const keys = Object.keys(allowed);
        if (!keys.length) return badRequest("No fields");
        const set = keys.map((k) => `${k}=?`).join(",");
        const binds = keys.map((k) => {
          const v = allowed[k];
          if (k === "name" || k === "currency") return v == null ? null : String(v).trim();
          if (k === "start_date") return v == null ? null : Number(v);
          if (k === "price") return v == null ? 0 : Number(v);
          if (k === "sort") return v == null ? 1000 : Number(v);
          if (k === "is_active") return Number(v) ? 1 : 0;
          return v;
        });
        await env.DB.prepare(`UPDATE ${table} SET ${set} WHERE id=?`).bind(...binds, id).run();
      }
      return jsonResp({ ok: true }, 200, corsHeaders(env, origin));
    }

    // soft delete: POST /api/settings/{dict}/{id}/delete
    if (method === "POST" && segments[4] === "delete") {
      await env.DB.prepare(`UPDATE ${table} SET is_active=0 WHERE id=?`).bind(id).run();
      return jsonResp({ ok: true }, 200, corsHeaders(env, origin));
    }

    return notFound();
  }

  // dict routes:
  // /api/settings/cities
  // /api/settings/spheres
  // /api/settings/sources
  // /api/settings/service_types
  // /api/settings/course_types
  if (segments[2] === "cities") return dictCrud("dict_cities", true);
  if (segments[2] === "spheres") return dictCrud("dict_spheres", true);
  if (segments[2] === "sources") return dictCrud("dict_sources", true);
  if (segments[2] === "service_types") return dictCrud("service_types", true);
  if (segments[2] === "course_types") return dictCrud("course_types", false);

  return notFound();
}

/** tasks endpoints */
async function handleTasks(env, user, request, origin, segments) {
  const method = request.method;
  const id = segments[2] ? intId(segments[2]) : null;

  // GET /api/tasks?assignee_user_id=&project_id=
  if (method === "GET" && !id) {
    const url = new URL(request.url);
    const assignee_user_id = url.searchParams.get("assignee_user_id");
    const project_id = url.searchParams.get("project_id");
    const filters = {
      assignee_user_id: assignee_user_id ? intId(assignee_user_id) : null,
      project_id: project_id ? intId(project_id) : null,
    };
    const rows = await queryTasksKanban(env, user, filters);
    return jsonResp({ ok: true, data: rows }, 200, corsHeaders(env, origin));
  }

  const body = await readJson(request);

  // POST /api/tasks (create)
  if (method === "POST" && !id) {
    if (!body) return badRequest("Expected JSON");
    const miss = requireFields(body, ["description", "assignee_user_id"]);
    if (miss) return badRequest(`Missing: ${miss}`);

    const assignee = intId(body.assignee_user_id);
    if (!assignee) return badRequest("Invalid assignee_user_id");

    // Only admin/rop can assign to others; others can only assign to self
    //if (!(user.role === "admin" || user.role === "rop") && assignee !== user.id) {
    //  return forbidden("You can assign only to yourself");
    //}

    const projectId = body.project_id ? intId(body.project_id) : null;
    const deadline_at = body.deadline_at == null ? null : Number(body.deadline_at);
    const title = body.title ? String(body.title).trim() : null;

    const res = await env.DB.prepare(
      `INSERT INTO tasks(title, description, assignee_user_id, project_id, status, deadline_at, is_active, created_by)
       VALUES(?,?,?,?, 'new', ?, 1, ?)`
    )
      .bind(title, String(body.description).trim(), assignee, projectId, deadline_at, user.id)
      .run();

    return jsonResp({ ok: true, data: { id: res.meta.last_row_id } }, 200, corsHeaders(env, origin));
  }

  if (!id) return notFound();

  // GET /api/tasks/:id
  if (method === "GET") {
    const ts = nowSec();
    const row = await env.DB.prepare(
      `SELECT
        t.*,
        u.full_name AS assignee_name,
        cu.full_name AS created_by_name,
        p.pm_user_id AS project_pm_user_id,
        c.company_name AS project_company_name,
        COALESCE((
          SELECT SUM(COALESCE(l.end_at, ?) - l.start_at) FROM task_time_logs l WHERE l.task_id=t.id
        ),0) AS spent_seconds
       FROM tasks t
       JOIN users u ON u.id=t.assignee_user_id
       JOIN users cu ON cu.id=t.created_by
       LEFT JOIN projects p ON p.id=t.project_id
       LEFT JOIN clients c ON c.id=p.client_id
       WHERE t.id=? AND t.is_active=1`
    )
      .bind(ts, id)
      .first();

    if (!row) return notFound();
    if (!canSeeTask(user, row)) return forbidden();

    return jsonResp({ ok: true, data: row }, 200, corsHeaders(env, origin));
  }

  // PUT /api/tasks/:id (edit) - only creator or admin can edit title/description/deadline/assignee/project
  if (method === "PUT") {
    if (!body) return badRequest("Expected JSON");

    const existing = await env.DB.prepare(
      `SELECT t.*, p.pm_user_id AS project_pm_user_id FROM tasks t LEFT JOIN projects p ON p.id=t.project_id
       WHERE t.id=? AND t.is_active=1`
    )
      .bind(id)
      .first();

    if (!existing) return notFound();
    if (!canSeeTask(user, existing)) return forbidden();

    const isOwner = existing.created_by === user.id;
    const isAdmin = user.role === "admin" || user.role === "rop";
    if (!(isOwner || isAdmin)) return forbidden("Only owner/admin can edit task");

    const allowed = pick(body, ["title", "description", "assignee_user_id", "project_id", "deadline_at"]);
    const keys = Object.keys(allowed);
    if (!keys.length) return badRequest("No fields");

    // assignee restrictions
    if (allowed.assignee_user_id != null) {
      const assignee = intId(allowed.assignee_user_id);
      if (!assignee) return badRequest("Invalid assignee_user_id");
      //if (!(user.role === "admin" || user.role === "rop") && assignee !== user.id) {
      //  return forbidden("You can assign only to yourself");
      //}
      allowed.assignee_user_id = assignee;
    }
    if (allowed.project_id !== undefined) {
      allowed.project_id = allowed.project_id ? intId(allowed.project_id) : null;
    }
    if (allowed.deadline_at !== undefined) {
      allowed.deadline_at = allowed.deadline_at == null ? null : Number(allowed.deadline_at);
    }
    if (allowed.title !== undefined) {
      allowed.title = allowed.title ? String(allowed.title).trim() : null;
    }
    if (allowed.description !== undefined) {
      allowed.description = String(allowed.description).trim();
      if (!allowed.description) return badRequest("description required");
    }

    const set = keys.map((k) => `${k}=?`).join(",");
    const binds = keys.map((k) => allowed[k]);
    await env.DB.prepare(`UPDATE tasks SET ${set} WHERE id=?`).bind(...binds, id).run();
    return jsonResp({ ok: true }, 200, corsHeaders(env, origin));
  }

  // POST /api/tasks/:id/move { status, cancel_reason? }
  if (method === "POST" && segments[3] === "move") {
    if (!body) return badRequest("Expected JSON");
    const miss = requireFields(body, ["status"]);
    if (miss) return badRequest(`Missing: ${miss}`);

    const status = String(body.status);
    if (!TASK_STATUSES.includes(status)) return badRequest("Invalid status");

    const task = await env.DB.prepare(`SELECT * FROM tasks WHERE id=? AND is_active=1`).bind(id).first();
    if (!task) return notFound();
    if (!canSeeTask(user, task)) return forbidden();

    // cancel requires reason
    const cancel_reason = body.cancel_reason ? String(body.cancel_reason).trim() : null;
    if (status === "canceled" && !cancel_reason) return badRequest("cancel_reason_required");

    const ts = nowSec();

    // If moving into in_progress: must be assignee or admin/rop moving for assignee
    if (status === "in_progress") {
      // only assignee can start (or admin/rop can start for them)
      if (!(user.role === "admin" || user.role === "rop") && task.assignee_user_id !== user.id) {
        return forbidden("Only assignee can start task");
      }

      // pause any other in_progress for that assignee and close their open logs
      await env.DB.batch([
        env.DB.prepare(
          `UPDATE tasks
           SET status='pause'
           WHERE is_active=1 AND assignee_user_id=? AND status='in_progress' AND id<>?`
        ).bind(task.assignee_user_id, id),

        env.DB.prepare(
          `UPDATE task_time_logs
           SET end_at=?
           WHERE user_id=? AND end_at IS NULL`
        ).bind(ts, task.assignee_user_id),

        env.DB.prepare(`UPDATE tasks SET status='in_progress', cancel_reason=NULL WHERE id=?`).bind(id),

        env.DB.prepare(
          `INSERT INTO task_time_logs(task_id,user_id,start_at,end_at)
           VALUES(?,?,?,NULL)`
        ).bind(id, task.assignee_user_id, ts),
      ]);

      return jsonResp({ ok: true }, 200, corsHeaders(env, origin));
    }

    // Leaving in_progress: close open log for this task+assignee
    if (task.status === "in_progress" && status !== "in_progress") {
      await env.DB.prepare(
        `UPDATE task_time_logs SET end_at=? WHERE task_id=? AND user_id=? AND end_at IS NULL`
      )
        .bind(ts, id, task.assignee_user_id)
        .run();
    }

    await env.DB.prepare(
      `UPDATE tasks SET status=?, cancel_reason=? WHERE id=?`
    )
      .bind(status, status === "canceled" ? cancel_reason : null, id)
      .run();

    return jsonResp({ ok: true }, 200, corsHeaders(env, origin));
  }

  // POST /api/tasks/:id/delete (soft)
  if (method === "POST" && segments[3] === "delete") {
    const task = await env.DB.prepare(`SELECT * FROM tasks WHERE id=? AND is_active=1`).bind(id).first();
    if (!task) return notFound();

    // Only owner (created_by) or admin/rop can delete
    const isOwner = task.created_by === user.id;
    const isAdmin = user.role === "admin" || user.role === "rop";
    if (!(isOwner || isAdmin)) return forbidden("Only owner/admin can delete");

    const ts = nowSec();
    await env.DB.prepare(
      `UPDATE tasks SET is_active=0, deleted_at=?, deleted_by=? WHERE id=?`
    )
      .bind(ts, user.id, id)
      .run();

    // close open logs
    await env.DB.prepare(
      `UPDATE task_time_logs SET end_at=? WHERE task_id=? AND end_at IS NULL`
    )
      .bind(ts, id)
      .run();

    return jsonResp({ ok: true }, 200, corsHeaders(env, origin));
  }

  return notFound();
}

/** projects endpoints */
async function handleProjects(env, user, request, origin, segments) {
  const method = request.method;
  const id = segments[2] ? intId(segments[2]) : null;

  // GET /api/projects?pm_user_id=&service_type_id=
  if (method === "GET" && !id) {
    const url = new URL(request.url);
    const pm_user_id = url.searchParams.get("pm_user_id");
    const service_type_id = url.searchParams.get("service_type_id");

    const filters = {
      pm_user_id: pm_user_id ? intId(pm_user_id) : null,
      service_type_id: service_type_id ? intId(service_type_id) : null,
    };

    const rows = await queryProjectsKanban(env, user, filters);
    return jsonResp({ ok: true, data: rows }, 200, corsHeaders(env, origin));
  }

  const body = await readJson(request);

  // POST /api/projects (create) - admin/rop/pm only
  if (method === "POST" && !id) {
    if (!(user.role === "admin" || user.role === "rop" || user.role === "pm")) {
      return forbidden("No access");
    }
    if (!body) return badRequest("Expected JSON");
    const miss = requireFields(body, ["client_id", "service_type_id", "pm_user_id"]);
    if (miss) return badRequest(`Missing: ${miss}`);

    const client_id = intId(body.client_id);
    const service_type_id = intId(body.service_type_id);
    const pm_user_id = intId(body.pm_user_id);
    if (!client_id || !service_type_id || !pm_user_id) return badRequest("Invalid ids");

    // PM can only create projects for themselves as pm_user_id
    if (user.role === "pm" && pm_user_id !== user.id) return forbidden("PM can set only —Å–µ–±—è –∫–∞–∫ PM");

    const meeting_at = body.meeting_at == null ? null : Number(body.meeting_at);
    const deadline_at = body.deadline_at == null ? null : Number(body.deadline_at);
    const comment = body.comment ? String(body.comment).trim() : null;

    let amount = body.amount == null ? null : Number(body.amount);
    let currency = body.currency ? String(body.currency).trim() : "UZS";

    // Only admin/rop can set amount
    if (!projectAmountVisible(user)) {
      amount = null;
      currency = "UZS";
    }

    const res = await env.DB.prepare(
      `INSERT INTO projects(
        client_id, service_type_id, meeting_at, deadline_at,
        amount, currency, pm_user_id, status, comment, is_active, created_by
      ) VALUES(?,?,?,?,?,?,?, 'new', ?, 1, ?)`
    )
      .bind(client_id, service_type_id, meeting_at, deadline_at, amount, currency, pm_user_id, comment, user.id)
      .run();

    return jsonResp({ ok: true, data: { id: res.meta.last_row_id } }, 200, corsHeaders(env, origin));
  }

  if (!id) return notFound();

  // GET /api/projects/:id
  if (method === "GET") {
    const row = await env.DB.prepare(
      `SELECT
        p.*,
        c.company_name, c.full_name AS owner_full_name, c.phone1 AS owner_phone1, c.phone2 AS owner_phone2,
        st.name_ru AS service_name_ru, st.name_uz AS service_name_uz, st.name_en AS service_name_en,
        u.full_name AS pm_name,
        cu.full_name AS created_by_name,
        CASE WHEN EXISTS (
          SELECT 1 FROM tasks t WHERE t.is_active=1 AND t.project_id=p.id AND t.assignee_user_id=?
        ) THEN 1 ELSE 0 END AS _fin_has_task
       FROM projects p
       JOIN clients c ON c.id=p.client_id
       JOIN service_types st ON st.id=p.service_type_id
       JOIN users u ON u.id=p.pm_user_id
       JOIN users cu ON cu.id=p.created_by
       WHERE p.id=? AND p.is_active=1`
    )
      .bind(user.id, id)
      .first();

    if (!row) return notFound();
    if (!canSeeProject(user, row)) return forbidden();

    if (!projectAmountVisible(user)) {
      delete row.amount;
      delete row.currency;
    }

    return jsonResp({ ok: true, data: row }, 200, corsHeaders(env, origin));
  }

  // PUT /api/projects/:id (edit) - admin/rop or PM(owner of project)
  if (method === "PUT") {
    if (!body) return badRequest("Expected JSON");
    const existing = await env.DB.prepare(
      `SELECT p.*,
        CASE WHEN EXISTS (
          SELECT 1 FROM tasks t WHERE t.is_active=1 AND t.project_id=p.id AND t.assignee_user_id=?
        ) THEN 1 ELSE 0 END AS _fin_has_task
       FROM projects p WHERE p.id=? AND p.is_active=1`
    )
      .bind(user.id, id)
      .first();

    if (!existing) return notFound();
    if (!canSeeProject(user, existing)) return forbidden();

    const isAdmin = user.role === "admin" || user.role === "rop";
    const isPmOwner = user.role === "pm" && existing.pm_user_id === user.id;
    if (!(isAdmin || isPmOwner)) return forbidden();

    const allowed = pick(body, [
      "client_id",
      "service_type_id",
      "meeting_at",
      "deadline_at",
      "amount",
      "currency",
      "pm_user_id",
      "comment",
      "review",
    ]);

    if (allowed.client_id !== undefined) allowed.client_id = allowed.client_id ? intId(allowed.client_id) : null;
    if (allowed.service_type_id !== undefined)
      allowed.service_type_id = allowed.service_type_id ? intId(allowed.service_type_id) : null;
    if (allowed.pm_user_id !== undefined) allowed.pm_user_id = allowed.pm_user_id ? intId(allowed.pm_user_id) : null;

    if (!isAdmin) {
      // PM cannot set amount, cannot change PM away from self
      delete allowed.amount;
      delete allowed.currency;
      if (allowed.pm_user_id != null && allowed.pm_user_id !== user.id) return forbidden("PM cannot change PM");
    }

    const keys = Object.keys(allowed);
    if (!keys.length) return badRequest("No fields");

    const set = keys.map((k) => `${k}=?`).join(",");
    const binds = keys.map((k) => {
      const v = allowed[k];
      if (k === "currency") return v == null ? "UZS" : String(v).trim();
      if (k === "comment") return v == null ? null : String(v).trim();
      if (k === "review") return (v == null || v === 0 || v === "0" || v === false) ? null : 1;
      if (k === "amount") return v == null ? null : Number(v);
      if (k.endsWith("_at")) return v == null ? null : Number(v);
      return v;
    });

    await env.DB.prepare(`UPDATE projects SET ${set} WHERE id=?`).bind(...binds, id).run();
    return jsonResp({ ok: true }, 200, corsHeaders(env, origin));
  }

  // POST /api/projects/:id/move { status, cancel_reason? }
  if (method === "POST" && segments[3] === "move") {
    if (!body) return badRequest("Expected JSON");
    const miss = requireFields(body, ["status"]);
    if (miss) return badRequest(`Missing: ${miss}`);

    const status = String(body.status);
    if (!PROJECT_STATUSES.includes(status)) return badRequest("Invalid status");
    const cancel_reason = body.cancel_reason ? String(body.cancel_reason).trim() : null;
    if (status === "canceled" && !cancel_reason) return badRequest("cancel_reason_required");

    const existing = await env.DB.prepare(
      `SELECT p.*,
        CASE WHEN EXISTS (
          SELECT 1 FROM tasks t WHERE t.is_active=1 AND t.project_id=p.id AND t.assignee_user_id=?
        ) THEN 1 ELSE 0 END AS _fin_has_task
       FROM projects p WHERE p.id=? AND p.is_active=1`
    )
      .bind(user.id, id)
      .first();

    if (!existing) return notFound();
    if (!canSeeProject(user, existing)) return forbidden();

    const isAdmin = user.role === "admin" || user.role === "rop";
    const isPmOwner = user.role === "pm" && existing.pm_user_id === user.id;
    if (!(isAdmin || isPmOwner)) return forbidden();

    await env.DB.prepare(`UPDATE projects SET status=?, cancel_reason=? WHERE id=?`)
      .bind(status, status === "canceled" ? cancel_reason : null, id)
      .run();

    return jsonResp({ ok: true }, 200, corsHeaders(env, origin));
  }

  // POST /api/projects/:id/delete (soft) admin/rop or PM owner
  if (method === "POST" && segments[3] === "delete") {
    const existing = await env.DB.prepare(`SELECT * FROM projects WHERE id=? AND is_active=1`).bind(id).first();
    if (!existing) return notFound();

    const isAdmin = user.role === "admin" || user.role === "rop";
    const isPmOwner = user.role === "pm" && existing.pm_user_id === user.id;
    if (!(isAdmin || isPmOwner)) return forbidden();

    const ts = nowSec();
    await env.DB.prepare(`UPDATE projects SET is_active=0, deleted_at=?, deleted_by=? WHERE id=?`)
      .bind(ts, user.id, id)
      .run();

    return jsonResp({ ok: true }, 200, corsHeaders(env, origin));
  }

  return notFound();
}

/** courses (course_leads) endpoints */
async function handleCourseLeads(env, user, request, origin, segments) {
  const method = request.method;
  const id = segments[2] ? intId(segments[2]) : null;

  // only admin/rop/sale
  if (!(user.role === "admin" || user.role === "rop" || user.role === "sale")) {
    return forbidden("No access");
  }

  // GET /api/course_leads?company_id=&course_type_id=
  if (method === "GET" && !id) {
    const url = new URL(request.url);
    const company_id = url.searchParams.get("company_id");
    const course_type_id = url.searchParams.get("course_type_id");

    const filters = {
      company_id: company_id ? intId(company_id) : null,
      course_type_id: course_type_id ? intId(course_type_id) : null,
    };

    const rows = await queryCourseLeadsKanban(env, user, filters);
    return jsonResp({ ok: true, data: rows }, 200, corsHeaders(env, origin));
  }

  const body = await readJson(request);

  // POST /api/course_leads (create) -> status always 'new'
  if (method === "POST" && !id) {
    if (!body) return badRequest("Expected JSON");
    const miss = requireFields(body, ["lead_client_id", "course_type_id"]);
    if (miss) return badRequest(`Missing: ${miss}`);

    const lead_client_id = intId(body.lead_client_id);
    const company_id = body.company_id ? intId(body.company_id) : null;
    const course_type_id = intId(body.course_type_id);
    if (!lead_client_id || !course_type_id) return badRequest("Invalid ids");

    // Load course type to snapshot price/start_date/currency
    const ct = await env.DB.prepare(`SELECT id, start_date, price, currency FROM course_types WHERE id=? AND is_active=1`)
      .bind(course_type_id)
      .first();
    if (!ct) return badRequest("course_type_not_found");

    const agreed_amount = body.agreed_amount == null ? null : Number(body.agreed_amount);
    const paid_amount = body.paid_amount == null ? null : Number(body.paid_amount);
    const comment = body.comment ? String(body.comment).trim() : null;

    // Create always status = new
    const res = await env.DB.prepare(
      `INSERT INTO course_leads(
        lead_client_id, company_id, course_type_id,
        course_price, course_start_date, currency,
        agreed_amount, paid_amount,
        status, comment, is_active, created_by
      ) VALUES(?,?,?,?,?,?,?,?, 'new', ?, 1, ?)`
    )
      .bind(
        lead_client_id,
        company_id,
        course_type_id,
        Number(ct.price || 0),
        ct.start_date == null ? null : Number(ct.start_date),
        String(ct.currency || "UZS"),
        agreed_amount,
        paid_amount,
        comment,
        user.id
      )
      .run();

    return jsonResp({ ok: true, data: { id: res.meta.last_row_id } }, 200, corsHeaders(env, origin));
  }

  if (!id) return notFound();

  // GET /api/course_leads/:id
  if (method === "GET") {
    const row = await env.DB.prepare(
      `SELECT
        cl.*,
        lead.full_name AS lead_full_name,
        lead.phone1 AS lead_phone1,
        lead.comment AS lead_comment,
        lead.city_id AS lead_city_id,
        lead.source_id AS lead_source_id,
        lead.sphere_id AS lead_sphere_id,
        COALESCE(dc.name_uz, dc.name_ru, dc.name_en) AS lead_city_name,
        COALESCE(ds.name_uz, ds.name_ru, ds.name_en) AS lead_source_name,
        COALESCE(dsp.name_uz, dsp.name_ru, dsp.name_en) AS lead_sphere_name,
        comp.company_name AS company_name,
        ct.name AS course_type_name,
        cu.full_name AS created_by_name
       FROM course_leads cl
       JOIN clients lead ON lead.id=cl.lead_client_id
       LEFT JOIN clients comp ON comp.id=cl.company_id
       LEFT JOIN dict_cities dc ON dc.id = lead.city_id
       LEFT JOIN dict_sources ds ON ds.id = lead.source_id
       LEFT JOIN dict_spheres dsp ON dsp.id = lead.sphere_id
       JOIN course_types ct ON ct.id=cl.course_type_id
       JOIN users cu ON cu.id=cl.created_by
       WHERE cl.id=? AND cl.is_active=1`
    )
      .bind(id)
      .first();

    if (!row) return notFound();

    if (!courseAmountVisible(user)) {
      delete row.course_price;
      delete row.agreed_amount;
      delete row.paid_amount;
      delete row.currency;
    }

    return jsonResp({ ok: true, data: row }, 200, corsHeaders(env, origin));
  }

  // PUT /api/course_leads/:id (edit fields)
  if (method === "PUT") {
    if (!body) return badRequest("Expected JSON");

    const allowed = pick(body, ["company_id", "course_type_id", "agreed_amount", "paid_amount", "comment"]);
    if (allowed.company_id !== undefined) allowed.company_id = allowed.company_id ? intId(allowed.company_id) : null;
    if (allowed.course_type_id !== undefined) allowed.course_type_id = allowed.course_type_id ? intId(allowed.course_type_id) : null;
    if (allowed.agreed_amount !== undefined) allowed.agreed_amount = allowed.agreed_amount == null ? null : Number(allowed.agreed_amount);
    if (allowed.paid_amount !== undefined) allowed.paid_amount = allowed.paid_amount == null ? null : Number(allowed.paid_amount);
    if (allowed.comment !== undefined) allowed.comment = allowed.comment ? String(allowed.comment).trim() : null;

    // If course_type changed -> re-snapshot price/start_date/currency
    let extraSet = "";
    const extraBinds = [];
    if (allowed.course_type_id) {
      const ct = await env.DB.prepare(`SELECT id, start_date, price, currency FROM course_types WHERE id=? AND is_active=1`)
        .bind(allowed.course_type_id)
        .first();
      if (!ct) return badRequest("course_type_not_found");
      extraSet = `, course_price=?, course_start_date=?, currency=?`;
      extraBinds.push(Number(ct.price || 0), ct.start_date == null ? null : Number(ct.start_date), String(ct.currency || "UZS"));
    }

    const keys = Object.keys(allowed).filter((k) => k !== "course_type_id");
    // if course_type_id present, we update it too
    if (allowed.course_type_id !== undefined) keys.push("course_type_id");

    if (!keys.length && !extraSet) return badRequest("No fields");

    const set = keys.map((k) => `${k}=?`).join(",");
    const binds = keys.map((k) => allowed[k]);

    await env.DB.prepare(`UPDATE course_leads SET ${set}${extraSet} WHERE id=?`)
      .bind(...binds, ...extraBinds, id)
      .run();

    return jsonResp({ ok: true }, 200, corsHeaders(env, origin));
  }

  // POST /api/course_leads/:id/move { status, cancel_reason?, paid_amount? }
  if (method === "POST" && segments[3] === "move") {
    if (!body) return badRequest("Expected JSON");
    const miss = requireFields(body, ["status"]);
    if (miss) return badRequest(`Missing: ${miss}`);

    const status = String(body.status);
    if (!COURSE_STATUSES.includes(status)) return badRequest("Invalid status");

    const cancel_reason = body.cancel_reason ? String(body.cancel_reason).trim() : null;
    if (status === "canceled" && !cancel_reason) return badRequest("cancel_reason_required");

    const paid_amount = body.paid_amount == null ? null : Number(body.paid_amount);

    const paidReq = await ensurePaidRequiredForCourseStatus(status, paid_amount);
    if (paidReq === "paid_amount_required") return badRequest("paid_amount_required");

    // update status, cancel_reason, optionally paid_amount
    if (status === "enrolled" || status === "studying") {
      await env.DB.prepare(
        `UPDATE course_leads SET status=?, cancel_reason=NULL, paid_amount=? WHERE id=?`
      )
        .bind(status, paid_amount, id)
        .run();
    } else {
      await env.DB.prepare(
        `UPDATE course_leads SET status=?, cancel_reason=?, paid_amount=COALESCE(?, paid_amount) WHERE id=?`
      )
        .bind(status, status === "canceled" ? cancel_reason : null, paid_amount, id)
        .run();
    }

    return jsonResp({ ok: true }, 200, corsHeaders(env, origin));
  }

  // POST /api/course_leads/:id/delete (soft)
  if (method === "POST" && segments[3] === "delete") {
    const ts = nowSec();
    await env.DB.prepare(`UPDATE course_leads SET is_active=0, deleted_at=?, deleted_by=? WHERE id=?`)
      .bind(ts, user.id, id)
      .run();
    return jsonResp({ ok: true }, 200, corsHeaders(env, origin));
  }

  return notFound();
}

/** clients endpoints */
async function handleClients(env, user, request, origin, segments) {
  const method = request.method;
  const id = segments[2] ? intId(segments[2]) : null;

  // RBAC:
  // admin/rop/sale: ok
  // pm: only companies
  // fin: no
  if (user.role === "fin") return forbidden("No access");

  // GET /api/clients?type=company|lead&q=
  if (method === "GET" && !id) {
    const url = new URL(request.url);
    const type = url.searchParams.get("type") || "";
    const q = url.searchParams.get("q") || "";

    if (type && type !== "company" && type !== "lead") return badRequest("Invalid type");
    if (user.role === "pm" && type && type !== "company") return forbidden("PM sees only companies");

    const rows = await queryClients(env, user, type || null, q);
    return jsonResp({ ok: true, data: rows }, 200, corsHeaders(env, origin));
  }

  const body = await readJson(request);

  // POST /api/clients (create)
  if (method === "POST" && !id) {
    if (!body) return badRequest("Expected JSON");
    const miss = requireFields(body, ["type", "full_name", "phone1"]);
    if (miss) return badRequest(`Missing: ${miss}`);

    const type = String(body.type);
    if (type !== "company" && type !== "lead") return badRequest("Invalid type");
    if (user.role === "pm" && type !== "company") return forbidden("PM can create only companies");

    const company_name = body.company_name ? String(body.company_name).trim() : null;
    const full_name = String(body.full_name).trim();
    const phone1 = normalizePhone(body.phone1);
    const phone2 = body.phone2 ? normalizePhone(body.phone2) : null;
    if (!phone1) return badRequest("Missing: phone1");

    const city_id = body.city_id ? intId(body.city_id) : null;
    const source_id = body.source_id ? intId(body.source_id) : null;
    const sphere_id = body.sphere_id ? intId(body.sphere_id) : null;

    const comment = body.comment ? String(body.comment).trim() : null;
    const tg_group_link = body.tg_group_link ? String(body.tg_group_link).trim() : null;

    const company_id = body.company_id ? intId(body.company_id) : null;

    // Reuse soft-deleted row with the same phone (avoid false "duplicate" on unique index)
    const pkey = phoneDigits(phone1);
    const samePhone = await env.DB.prepare(
      `SELECT id, is_active
       FROM clients
       WHERE replace(replace(replace(replace(replace(phone1,'+',''),' ',''),'-',''),'(',''),')','') = ?
       ORDER BY is_active DESC, id DESC
       LIMIT 1`
    )
      .bind(pkey)
      .first();

    if (samePhone && Number(samePhone.is_active) === 1) {
      return badRequest("Phone already exists (duplicate phone1?)");
    }

    try {
      if (samePhone && Number(samePhone.is_active) === 0) {
        await env.DB.prepare(
          `UPDATE clients
           SET type=?, company_name=?, full_name=?, phone1=?, phone2=?,
               city_id=?, source_id=?, sphere_id=?, comment=?, tg_group_link=?, company_id=?,
               is_active=1, deleted_at=NULL, deleted_by=NULL
           WHERE id=?`
        )
          .bind(
            type,
            company_name,
            full_name,
            phone1,
            phone2,
            city_id,
            source_id,
            sphere_id,
            comment,
            tg_group_link,
            company_id,
            samePhone.id
          )
          .run();
        return jsonResp({ ok: true, data: { id: samePhone.id, restored: true } }, 200, corsHeaders(env, origin));
      }

      const res = await env.DB.prepare(
        `INSERT INTO clients(
          type, company_name, full_name, phone1, phone2,
          city_id, source_id, sphere_id, comment, tg_group_link, company_id,
          is_active, created_by
        ) VALUES(?,?,?,?,?,?,?,?,?,?,?, 1, ?)`
      )
        .bind(
          type,
          company_name,
          full_name,
          phone1,
          phone2,
          city_id,
          source_id,
          sphere_id,
          comment,
          tg_group_link,
          company_id,
          user.id
        )
        .run();

      return jsonResp({ ok: true, data: { id: res.meta.last_row_id } }, 200, corsHeaders(env, origin));
    } catch {
      return badRequest("Phone already exists (duplicate phone1?)");
    }
  }

  if (!id) return notFound();

  // GET /api/clients/:id
  if (method === "GET") {
    const data = await getClientCard(env, user, id);
    if (!data) return notFound();
    return jsonResp({ ok: true, data }, 200, corsHeaders(env, origin));
  }

  // PUT /api/clients/:id
  if (method === "PUT") {
    if (!body) return badRequest("Expected JSON");

    const existing = await env.DB.prepare(`SELECT * FROM clients WHERE id=? AND is_active=1`).bind(id).first();
    if (!existing) return notFound();
    if (user.role === "pm" && existing.type !== "company") return forbidden("PM sees only companies");

    const allowed = pick(body, [
      "company_name",
      "full_name",
      "phone1",
      "phone2",
      "city_id",
      "source_id",
      "sphere_id",
      "comment",
      "tg_group_link",
      "company_id",
    ]);

    // normalize
    if (allowed.company_name !== undefined) allowed.company_name = allowed.company_name ? String(allowed.company_name).trim() : null;
    if (allowed.full_name !== undefined) allowed.full_name = allowed.full_name ? String(allowed.full_name).trim() : null;
    if (allowed.phone1 !== undefined) allowed.phone1 = allowed.phone1 ? normalizePhone(allowed.phone1) : null;
    if (allowed.phone2 !== undefined) allowed.phone2 = allowed.phone2 ? normalizePhone(allowed.phone2) : null;

    if (allowed.city_id !== undefined) allowed.city_id = allowed.city_id ? intId(allowed.city_id) : null;
    if (allowed.source_id !== undefined) allowed.source_id = allowed.source_id ? intId(allowed.source_id) : null;
    if (allowed.sphere_id !== undefined) allowed.sphere_id = allowed.sphere_id ? intId(allowed.sphere_id) : null;

    if (allowed.comment !== undefined) allowed.comment = allowed.comment ? String(allowed.comment).trim() : null;
    if (allowed.tg_group_link !== undefined) allowed.tg_group_link = allowed.tg_group_link ? String(allowed.tg_group_link).trim() : null;
    if (allowed.company_id !== undefined) allowed.company_id = allowed.company_id ? intId(allowed.company_id) : null;

    const keys = Object.keys(allowed);
    if (!keys.length) return badRequest("No fields");

    const set = keys.map((k) => `${k}=?`).join(",");
    const binds = keys.map((k) => allowed[k]);

    try {
      await env.DB.prepare(`UPDATE clients SET ${set} WHERE id=?`).bind(...binds, id).run();
      return jsonResp({ ok: true }, 200, corsHeaders(env, origin));
    } catch {
      return badRequest("Update failed (duplicate phone1?)");
    }
  }

  // POST /api/clients/:id/delete (soft)
  if (method === "POST" && segments[3] === "delete") {
    const ts = nowSec();
    await env.DB.prepare(`UPDATE clients SET is_active=0, deleted_at=?, deleted_by=? WHERE id=?`)
      .bind(ts, user.id, id)
      .run();
    return jsonResp({ ok: true }, 200, corsHeaders(env, origin));
  }

  return notFound();
}

/** main dashboard: overdue/today/in_progress for responsible */
async function handleMain(env, user, origin) {
  const ts = nowSec();
  const { startOfDayUtcSec, endOfDayUtcSec } = tashkentDayBounds(ts);

  // only tasks for responsible user (–ø–æ –¢–ó)
  const overdue = await env.DB.prepare(
    `SELECT id, title, description, status, deadline_at, project_id
     FROM tasks
     WHERE is_active=1 AND assignee_user_id=? AND deadline_at IS NOT NULL AND deadline_at < ? AND status NOT IN ('done','canceled')
     ORDER BY deadline_at ASC LIMIT 200`
  )
    .bind(user.id, startOfDayUtcSec)
    .all();

  const today = await env.DB.prepare(
    `SELECT id, title, description, status, deadline_at, project_id
     FROM tasks
     WHERE is_active=1 AND assignee_user_id=? AND deadline_at IS NOT NULL AND deadline_at BETWEEN ? AND ?
     ORDER BY deadline_at ASC LIMIT 200`
  )
    .bind(user.id, startOfDayUtcSec, endOfDayUtcSec)
    .all();

  const inProgress = await env.DB.prepare(
    `SELECT id, title, description, status, deadline_at, project_id
     FROM tasks
     WHERE is_active=1 AND assignee_user_id=? AND status='in_progress'
     LIMIT 1`
  )
    .bind(user.id)
    .first();

  return jsonResp(
    {
      ok: true,
      data: {
        overdue: overdue.results || [],
        today: today.results || [],
        in_progress: inProgress || null,
      },
    },
    200,
    corsHeaders(env, origin)
  );
}

async function handleMeta(env, user, origin) {
  return jsonResp(
    {
      ok: true,
      data: {
        roles: ROLES,
        statuses: {
          tasks: TASK_STATUSES,
          projects: PROJECT_STATUSES,
          courses: COURSE_STATUSES,
        },
      },
    },
    200,
    corsHeaders(env, origin)
  );
}

export default {
  async fetch(request, env) {
    const url = new URL(request.url);
    const origin = request.headers.get("Origin") || "";

    // Preflight
    if (request.method === "OPTIONS") {
      return new Response(null, { status: 204, headers: corsHeaders(env, origin) });
    }

    // Auto-pause overnight in_progress tasks (—Å—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—Ä–æ—Å–µ –ø–æ—Å–ª–µ –ø–æ–ª—É–Ω–æ—á–∏)
    // (–ø–æ –¢–ó: Jarayonda –¥–æ 23:59:59 –∏ –ø–æ—Ç–æ–º –≤ Pauza):contentReference[oaicite:3]{index=3}
    try {
      await autoPauseOvernight(env);
    } catch {
      // don't block request if maintenance fails
    }

    // Only API routes
    if (!url.pathname.startsWith("/api/")) {
      return withCors(
        jsonResp({ ok: false, error: { code: "not_found", message: "API only" } }, 404),
        env,
        origin
      );
    }

    const segments = url.pathname.split("/").filter(Boolean); // ["api", "..."]
    const apiRoot = segments[1] || "";

    // Public
    if (apiRoot === "health") {
      return withCors(jsonResp({ ok: true, ts: nowSec() }, 200), env, origin);
    }

    if (apiRoot === "auth" && segments[2] === "login" && request.method === "POST") {
      return withCors(await handleAuthLogin(env, request, origin), env, origin);
    }

    // Telegram webhook (public)
    if (apiRoot === "telegram" && segments[2] === "webhook" && request.method === "POST") {
      return withCors(await handleTelegramWebhook(env, request), env, origin);
    }

    // Auth required below
    const user = await getSessionUser(env, request);
    if (!user) {
      // also allow logout without valid session (will just clear cookie)
      if (apiRoot === "auth" && segments[2] === "logout" && request.method === "POST") {
        return withCors(await handleAuthLogout(env, request, origin), env, origin);
      }
      return withCors(unauthorized("–°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞ –∏–ª–∏ –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω –≤—Ö–æ–¥"), env, origin);
    }

    // "–≤—Ö–æ–¥ –¥–µ—Ä–∂–∏—Ç—Å—è –¥–æ 23:59:59":contentReference[oaicite:4]{index=4}
    if (apiRoot === "auth" && segments[2] === "me" && request.method === "GET") {
      return withCors(jsonResp({ ok: true, data: { user } }, 200), env, origin);
    }
    if (apiRoot === "auth" && segments[2] === "logout" && request.method === "POST") {
      return withCors(await handleAuthLogout(env, request, origin), env, origin);
    }

    // meta
    if (apiRoot === "meta" && request.method === "GET") {
      return withCors(await handleMeta(env, user, origin), env, origin);
    }

    // main
    if (apiRoot === "main" && request.method === "GET") {
      return withCors(await handleMain(env, user, origin), env, origin);
    }

    // users (admin only):contentReference[oaicite:5]{index=5}
    if (apiRoot === "users") {
      return withCors(await handleUsers(env, user, request, origin, segments), env, origin);
    }

    // settings (admin only):contentReference[oaicite:6]{index=6}
    if (apiRoot === "settings") {
      return withCors(await handleSettings(env, user, request, origin, segments), env, origin);
    }

    // tasks
    if (apiRoot === "tasks") {
      return withCors(await handleTasks(env, user, request, origin, segments), env, origin);
    }

    // projects
    if (apiRoot === "projects") {
      return withCors(await handleProjects(env, user, request, origin, segments), env, origin);
    }

    // courses
    if (apiRoot === "course_leads") {
      return withCors(await handleCourseLeads(env, user, request, origin, segments), env, origin);
    }

    // clients
    if (apiRoot === "clients") {
      return withCors(await handleClients(env, user, request, origin, segments), env, origin);
    }

    return withCors(notFound(), env, origin);
  },
};

